/* Chapter 14. atouMT.
	Multithreaded ASCII to Unicode file conversion.
	Use threads as an alternative to overlapped I/O. 
	The resulting code is MUCH simpler. */
/* atouMT file1 file2 */
#include "EvryThng.h"

#define MAX_OVRLP 4  /* Number of worker threads */
#define RECORD_SIZE 0x10000  /* 65k block size */
#define SFP_ERROR 0xFFFFFFFF  /* Error getting size of file  */

DWORD WINAPI ReadWrite (LPVOID);
typedef struct TH_ARG_T {
	HANDLE hIn;
	HANDLE hOut;
	volatile DWORD ThreadNum;
} TH_ARG;

int _tmain (int argc, LPTSTR argv [])
{
	HANDLE hThr [MAX_OVRLP];
	HANDLE hProc = GetCurrentProcess ();
	DWORD i, ThId;
	TH_ARG ThArg[MAX_OVRLP];

	if (argc != 3)
		ReportError (_T ("Usage: atouMT file1 file2"), 1, FALSE);

	for (i = 0; i < MAX_OVRLP; i++) {
		ThArg[i].ThreadNum = i;

		/* Note: If you create just two handles (one for input, one for output)
			and then use DuplicateHandle to create individual handles for each
			thread (i.e., ThArg[i].hOut, etc. are generated by DuplicateHandle),
			you'll have problems. It appears is if ReadFile and WriteFile are
			not thread safe when dealing with duplcated handles. This is the case
			even if you protect the ReadFile and WriteFile with a CRITIAL_SECTION
			and even if you use the no buffering and write through flags. 
			As an exercise, try using duplecated handles. You will see errors if
			you compare the unicode output file with one generated with a correct
			atouXX program. */
		ThArg[i].hIn = CreateFile (argv [1], GENERIC_READ,
			FILE_SHARE_READ, NULL, OPEN_EXISTING,
			FILE_ATTRIBUTE_NORMAL, NULL);
 		if (ThArg[i].hIn == INVALID_HANDLE_VALUE) 
			ReportError (_T ("Fatal error opening input file."), 2, TRUE);

		ThArg[i].hOut = CreateFile (argv [2], GENERIC_READ | GENERIC_WRITE,
			FILE_SHARE_READ | FILE_SHARE_WRITE, NULL, CREATE_ALWAYS,
			FILE_ATTRIBUTE_NORMAL /*| FILE_FLAG_NO_BUFFERING | FILE_FLAG_WRITE_THROUGH*/, NULL);
		/* Note: DO NOT USE THE TWO COMMENTED OUR FLAGS AS THEY REQUIRE THAT THE OUTPUT
			BUFFER LENGTHS BE SECTOR SIZE MULTIPLES (THE WRITE WILL FAIL ) */
		if (ThArg[i].hOut == INVALID_HANDLE_VALUE) 
			ReportError (_T ("Fatal error opening output file."), 3, TRUE);

		hThr [i] = (HANDLE) _beginthreadex (NULL, 0, ReadWrite, (LPVOID)&ThArg[i], 0, &ThId);
		if (hThr [i] == NULL)
			ReportError (_T ("Error creating thread."), 6, TRUE);
	}

	for (i = 0; i < MAX_OVRLP; i++) {
		WaitForSingleObject (hThr [i], INFINITE);
		CloseHandle (hThr [i]);
		CloseHandle (ThArg[i].hOut); CloseHandle (ThArg[i].hIn);
	}
	_tprintf (_T ("Multithreaded ASCII to Unicode conversion completed.\n"));
	return 0;
}

DWORD WINAPI ReadWrite (LPVOID pArg)
{
  	CHAR AsRec [RECORD_SIZE];
	WCHAR UnRec [RECORD_SIZE];
	LARGE_INTEGER CurPosIn, CurPosOut, FileSize;
	DWORD i, nRead = 1, nWrite, iTh, inPos, ouPos;
	HANDLE hIn, hOut;
	TH_ARG * pThArg;

	pThArg = (TH_ARG *)pArg;

	iTh = pThArg->ThreadNum;
	hIn = pThArg->hIn; hOut = pThArg->hOut;

	FileSize.LowPart = GetFileSize (hIn, &FileSize.HighPart);
	CurPosIn.QuadPart = (LONGLONG) RECORD_SIZE * iTh;
	CurPosOut.QuadPart = (LONGLONG) RECORD_SIZE * (LONGLONG)(iTh * 2);
	while (CurPosIn.QuadPart < FileSize.QuadPart) {
		inPos = SetFilePointer (hIn, CurPosIn.LowPart,
			&CurPosIn.HighPart, FILE_BEGIN);
		if (inPos == SFP_ERROR && GetLastError() != NO_ERROR) 
			ReportError (_T("Error positioning input file"), 6, TRUE);
		
		ouPos = SetFilePointer (hOut, CurPosOut.LowPart,
			&CurPosOut.HighPart, FILE_BEGIN);
		if (ouPos == SFP_ERROR && GetLastError() != NO_ERROR) 
			ReportError (_T("Error positioning output file"), 7, TRUE);

		if (!ReadFile (hIn, AsRec, RECORD_SIZE, &nRead, NULL))
			ReportError (_T("Error reading input file"), 8, TRUE);

		for (i = 0; i < nRead; i++)
			UnRec [i] = (WCHAR)AsRec [i];
		
		if (!WriteFile (hOut, UnRec, 2*nRead, &nWrite, NULL))
			ReportError (_T("Error writing output file"), 9, TRUE);
		CurPosIn.QuadPart += (LONGLONG) RECORD_SIZE * MAX_OVRLP;
		CurPosOut.QuadPart += (LONGLONG) RECORD_SIZE * 2 * MAX_OVRLP;
	}

	CloseHandle (hIn);
	CloseHandle (hOut);
	return 0;
}